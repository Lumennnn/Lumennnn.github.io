---
title: C基础
date: 2021-03-06 21:41:37
#index_img: https://resource.liangzai.online/resource/python.png
categories:
  - 计算机学习
tags:
  - C
---

## C基础知识
<!-- more -->

**程序**：为了让计算机执行某些操作或解决某个问题而编写的一系列有序指令的集合
> 计算机指令：指挥机器工作的指示和命令

**算法**：是一个定义明确的计算过程，可以将一些值或一组值作为输入并产生一些值或一组值作为输出。因此算法就是将输入转化为输出的一系列计算步骤

**编译和执行过程**：
>
> 1. 编译：形成目标文件/代码。目标文件是编译器的输出结果，常见扩展名为“.o”或“.obj”
> 2. 连接：将目标代码跟C函数库相连接，并将源程序所用的库代码与目标代码合并形成最终可执行的二进制机器代码
> 3. 执行：在特定的机器环境下运行C应用程序

计算机使用内存来记忆或存储计算时所使用的数据
>
> 计算机在执行程序时，组成程序的指令和程序所操作的数据都必须存放在计算机的内存中
> 内存：也成为主存（main memory）或随机访问储存器（Random Access Memorry）

bit（位），binary digit（二进制数字）

8 bit(比特) = 1 byte(字节)

**变量**：计算机中一块特定的内存空间，由一个或多个连续的字节组成

**C语言变量命名规则**：
>
> 1. 只能由字母、数字和下划线三种字符组成，且第一个字母必须位字母或下划线
> 2. 变量名不能包含除_以外的任何特殊字符
> 3. 不可以使用保留字

**数据类型**：
>
> * 数值
>   * 整形
>     * int
>     * short
>     * long
>   * 非整形
>     * float
>     * double
> * 非数值
>   * char
>   * str

清除缓冲区  fflush(stdin)

**运算符**：
>
> * 赋值运算符
> * 算术运算符
>   * 一元运算符: ++、--
>   * 二元运算符：+、-、*、/、%
> * 关系运算符
> * 逻辑运算符：&&且、||或、!非
> * 位运算符

**使用switch结构时的注意点**：
>
> 1. switch后的表达式只能是整型或字符型
> 2. case后常量表达式的值不能相同
> 3. case后允许多条语句，不需要大括号
> 4. 如果不添加break语句，需要特别注意执行顺序
> 5. default子句可以省略

**continue**: 跳过本次循环，继续下次循环

**数组**：是一个变量，由数据类型相同的一组元素组成的
>
> 1. 标识符：数组的名称，用于区分不同的数组
> 2. 数组元素：向数组中存放的数据
> 3. 元素下标：对数组元素进行编号
> 4. 元素类型：数组元素的数据类型

**枚举**：enum　枚举名　{枚举元素1,枚举元素2,……} 枚举变量
> 每一个变量都有一个内存地址，每一个内存位置都定义了可使用&运算符访问的地址，它表示了在内存中的一个地址。

**指针**：指针也就是内存地址，指针变量用来存放内存地址的变量，就像其他变量或常量一样，必须在使用指针存储其他变量地址之前，对其进行声明。type *var-name  星号用来指定一个变量是指针
>
> 1. 所有实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，对应指针的值的类型都是一样的，都是一个代表内存地址的长的十六进制数。不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。
> 2. 通过使用一元运算符 * 来返回位于操作数所指定地址的变量的值
> 3. 在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为空指针。
> 4. 在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。

**C指针的算数运算**：C 指针是一个用数值表示的地址。因此，您可以对指针执行算术运算。可以对指针进行四种算术运算：++、--、+、-。
>
> 1. 指针的每一次递增，它其实都会指向下一个元素的存储单位
> 2. 指针的每一次递减，它都会指向前一个元素的存储单位
> 3. 指针在递增和递减时跳跃的字节数取决于指针所指向变量数据类型长度，比如int就是4个字节
> 4. 指针可以用关系运算符进行比较，如 ==、<和>。如果 p1 和 p2 指向两个相关的变量，比如同一个数组中的不同元素，则可对 p1 和 p2 进行大小比较。

**指针数组**：int *ptr[MAX];
> 把 ptr 声明为一个数组，由 MAX 个整数指针组成。因此，ptr 中的每个元素，都是一个指向 int 值的指针。 也可以用一个指向字符的指针数组来存储一个字符串列表。ptr[i] →*(ptr + i)

**C指向指针的指针**：指向指针的指针时一种多级间寻址的形式，或者说是一个指针链。当我们定义一个指向指针的指针时，第一个指针包含了第二个指针的地址，第二个指针指向包含实际值的位置。一个指向指针的指针变量必须如下声明，即在变量名前放置两个星号： int **var;
> 当一个目标值被一个指针间接指向到另一个指针时，访问这个值需要使用两个星号运算符

**C传递指针给函数**：C 语言允许传递指针给函数，只需要简单地声明函数参数为指针类型即可
> 能接受指针作为参数的函数，也能接受数组作为参数

**函数指针**：是指向函数的指针变量
> 通常我们说的指针变量是指向一个整形、字符型或数组等变量，而函数指针是指向函数，函数指针可以像一般函数一样，用于调用函数、传递参数。

**函数**：
>
> 1. 是完成特定任务的独立程序代码
> 2. 语法规则定义了函数的结构和使用方式

零表示假，非零表示真

**关于free函数**：
>
> 1. 必须是通过molloc、calloc或realloc分配内存的指针
> 2. 释放的指针必须是初始分配的地址，进行运算后需要恢复

**自定义函数**：
>
> * 函数三要素：
>   * 返回值类型
>   * 函数名
>   * 参数列表
> * 返回值
>   * 关键字：return
>   * 只能返回一个值，不能返回多个值
>   * 返回值类型必须与原型中的返回值类型匹配
>   * return会立即终止函数并返回，可返回空值
> * 参数
>   * 形式参数
>   * 实际参数

declare：宣布；宣告；宣称；表明 网络 声明；申报；断言

**变量的存储类型**：
>
> 1. auto     自动存储
> 2. register 寄存器存储
> 3. static   静态存储
> 4. extern   外部变量

**变量的生存周期**：
>
> 1. 变量的存储方式：动态存储（自动、寄存器）、静态存储（静态和外部）
> 2. 由变量的存储方式不同而产生的特性称为变量的生存期（变量的存在时间）
> 3. 基本类型的静态变量系统默认赋初值为0
> 4. 静态变量的生存周期为整个源程序，作用域只是定义它的文件
> 5. 函数被调用时，其中的局部静态变量的值保留前次被调用的结果

**按值传递**：给函数传递变元（参数）时，变元（参数）值不会直接传递给函数，而是先制作变元（参数）值的副本，存储在栈上，再使这个副本可用于函数，而不是使用初始值。

**引用传递**：指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数

**自定义头文件**：一般放一些重复使用的代码，例如函数声明，变量声明，常量声明，宏的定义等
>
> 1. MYHEADER_H_INCLUDED为一个唯一的标记，命名规则跟变量的命名规则一样，常根据它所在的头文件名来命名
> 2. 代码含义：如果没有定义MYHEADER_H_INCLUDED，则定义MYHEADER_H_INCLUDED，并编译下面的代码部分，直到遇到#endif

**字符串**：
>
> 1. 一个或多个字符的序列称为字符串
> 2. 双引号不是字符串的一部分，仅用来告知编译器括起来的是字符串
> 3. C语言中字符串使用字符数组存储
> 4. 声明存储字符串的数组时，数组大小至少比所存储的字符数多1，因为编译器会自动在字符串常量的末尾添加空字符\0

**gets和puts函数**：
>
> * gets函数不对接受字符串的buffer进行边界检测，会造成越界，从而产生bug
> * 可以使用fgets(words1, 20, stdin);代替gets，20表示最多读取20-1个字符，默认给最后一个元素回车
> * 三种方式录入字符串
>   * scanf("%s", str);
>   * gets(str);
>   * fgets(str, 50, stdin);

**常用字符串处理函数**：
>
> 1. size_t strlen(const char *)  获取字符串长度
> 2. char *strupr(char*)  将字符串转换为大写
> 3. char *strlwr(char*)  将字符串转换为小写
> 4. char *strcopy(char*, const char *)  把第二个字符串复制到第一个字符串数组中
> 5. in strcmp(const char*, constr char*)  根据ASCII码比较字符串
> 6. char *strcat(char*, const char *)    字符串连接，把第二个元素连接到第一个元素后

数组为常量
>
**指向字符串的指针**：
>
> * 将指针指向字符串
>   * 可以指向常量字符串
>   * 也可以指向存储字符串的字符数组
> * 数组形式和执行形式的不同
>   * 初始化字符数组时会把静态存储区的字符串拷贝到数组中
>   * 初始化指针时只把字符串的地址拷贝给指针

**结构**：一种构造数据类型，由若干个数据项组合而成
> struct StructName
> {
> //结构成员
> DataType1 var1;
> DataType2 var2;
> //...
> } VAR1, VAR2;
>
> 1. 结构定义并不预留内存
> 2. 结构定义一般放在程序的开始部分（头文件声明之后）
> 3. 结构定义仅用来描述结构的形式，使用结构需要声明结构变量
> 4. 定义结构的同时，声明结构变量

**指向结构的指针**：
>
> * 一个指针指向结构时，称为结构指针变量
> * 结构指针变量中的值是所指向的结构变量的首地址
> * 一般形式：struct 结构名称 结构指针变量名;
> * 访问结构成员的一般形式：
>   * (*结构指针变量).成员变量名
>   * 结构指针变量->成员变量名

**结构数组**：元素为结构类型的数组

**向函数传递结构的信息**：
>
> * 结构作为函数参数的三种方式
>   * 传递结构成员
>   * 传递结构
>     * 优点：函数处理的是原始数据的副本，保护了原始数据
>     * 缺点：老版本不支持；传递结构浪费时间和存储空间
>     * 一般用来处理小型数据结构
>   * 传递结构的地址
>     * 优点：程序的执行速度快，效率高
>     * 缺点：无法保护数据，函数中的操作可能会意外影响原结构中的数据
>     * 为了最求效率，常用此方案

**typedef**：可以为某一类型自定义名称
> 并没有创造任何新类型，只是为某个已存在的类型增加一个方便使用的标签

枚举和联合
