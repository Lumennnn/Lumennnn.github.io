<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>python进阶知识</title>
    <link href="/2021/08/06/python%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/"/>
    <url>/2021/08/06/python%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="进阶知识"><a href="#进阶知识" class="headerlink" title="进阶知识"></a>进阶知识</h2><p><strong>Python 中函数带括号和不带括号的区别</strong>：</p><blockquote><ol><li>不带括号时，调用的是这个函数本身，是整个函数体，是一个函数对象，不需要等待该函数执行完成</li><li>带括号（此时必须传入需要的参数），调用的函数的return结果，需要等待函数执行完成的结果</li><li>如果函数本身带有参数的时候，带括号就必须带参数，同理，函数本身不带参数，带括号就不能带参数</li></ol></blockquote><p>范例：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span>(<span class="hljs-params">x</span>)</span><br><span class="hljs-function">    <span class="hljs-title">print</span>(<span class="hljs-params"><span class="hljs-string">&quot;!&quot;</span></span>)</span><br><span class="hljs-function">    <span class="hljs-title">return</span> <span class="hljs-title">x</span></span><br><span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-params">a</span>)</span><br><span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-params">a(<span class="hljs-params"><span class="hljs-number">10</span></span>)</span>)</span><br></code></pre></div></td></tr></table></figure><p>输出结果：</p><figure class="highlight cmd"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmd">&lt;function a <span class="hljs-built_in">at</span> <span class="hljs-number">0</span>x&gt;<br><span class="hljs-number">10</span><br></code></pre></div></td></tr></table></figure><p><strong>函数参数</strong>：<br><img src="python%E5%8F%82%E6%95%B0.jpg" alt="python参数"></p><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><h4 id="形式参数"><a href="#形式参数" class="headerlink" title="形式参数"></a>形式参数</h4><p>形参即在定义函数时，括号内声明的参数。本质上是一个变量名，用来接受外部传来的值</p><h4 id="实际参数"><a href="#实际参数" class="headerlink" title="实际参数"></a>实际参数</h4><p>实参即调用函数时，括号内传入的值，值可以是常量、变量、表达式或三者的组合</p><h4 id="形参与实参的具体使用"><a href="#形参与实参的具体使用" class="headerlink" title="形参与实参的具体使用"></a>形参与实参的具体使用</h4><ol><li><p>位置参数</p><p>在定义函数时，按照从左到右的顺序依次定义形参，称为位置形参，凡是按照这种形式定义的形参都必须被传值</p><p>在调用函数时，按照从左到右的顺序依次定义实参，称为位置实参，凡是按照这种形式定义的实参会按照从左到右的我顺序与形参一一对应</p></li><li><p>关键字参数</p><p>在调用函数时，实参可以是 key=value 的形式，称为关键字参数，凡是按照这种形式定义的实参，可以完全不按照从左到右的顺序定义，但仍能为指定的形参赋值</p><p>需要注意在调用函数时，实参也可以是按位置或按关键字的混合使用，但必须保证关键字参数在位置参数后面，且不可以对一个形参重复赋值</p></li><li><p>默认参数</p><p>在定义函数时，就已经为形参赋值，这类形参称之为默认参数，当函数有多个参数时，需要将值经常改变的参数定义成位置参数，而将值改变较少的参数定义成默认参数。</p><blockquote><p>默认参数必须在位置参数之后<br>默认参数的值仅在函数定义阶段被赋值一次</p></blockquote></li><li><p>可变长参数</p><ul><li><p>可变长度的位置参数</p><p> 如果在最后一个形参名前加*号，那么在调用函数时，溢出的位置实参，都会被接收，以<em>元组</em>的形式保存下来赋值给该形参</p><p> 如果我们事先生成了一个列表，仍然是可以传值给 *args 的<br> 如果形参为常规参数（位置或默认），实参仍可以是 * 的形式<br> 注意：如果在传入 L 时没有加 *, 那 L 就只是一个普通的位置参数</p></li><li><p>可变长度的关键字参数</p><p> 如果在最后一个形参名前加**号，那么在调用函数时，溢出的关键字参数，都会被接收，以<em>字典</em>的形式保存下来赋值给该形参</p><p> 如果我们事先生成了一个字典，仍然是可以传值给 **kwargs的<br> 如果形参为常规参数（位置或默认），实参仍可以是 ** 的形式<br> 注意：如果在传入 dic 时没有加 **, 那 dic 就只是一个普通的位置参数了</p></li></ul></li><li><p>命名关键字参数</p><p>想要限定函数的调用者必须以 key=value 的形式传值，Python3 提供了专门的语法：需要在定义形参时，用*作为一个分隔符号，*号之后的形参称为命名关键字参数。对于这类参数，在函数调用时，必须按照 key=value 的形式为其传值，且必须被传值</p><p>命名关键字参数也可以有默认值，从而简化调用</p><p>如果形参中已经有一个*args 了，命名关键字参数就不再需要一个单独的 *作为分隔符号了</p></li><li><p>组合使用</p><p>所有参数可任意组合使用，但定义顺序必须是：位置参数、默认参数、args、命名关键字参数、*kwargs</p><p>可变参数*args 与关键字参数**kwargs 通常是组合在一起使用的，如果一个函数的形参为*args与**kwargs，那么代表该函数可以接收任何形式、任意长度的参数</p><p>在该函数内部还可以把接收到的参数传给另外一个函数</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span>(<span class="hljs-params">x, y, z</span>):</span><br>   print(x, y)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):</span><br>   func(*args, **kwargs)<br><br>wrapper(<span class="hljs-number">1</span>, z=<span class="hljs-number">3</span>, y=<span class="hljs-number">2</span>)<br></code></pre></div></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">1 2 3<br></code></pre></div></td></tr></table></figure></li></ol><p><strong>装饰器</strong>：</p><h3 id="在代码运行期间动态增加功能的方式，称之为-“装饰器”（Decorator）"><a href="#在代码运行期间动态增加功能的方式，称之为-“装饰器”（Decorator）" class="headerlink" title="在代码运行期间动态增加功能的方式，称之为 “装饰器”（Decorator）"></a>在代码运行期间动态增加功能的方式，称之为 “装饰器”（Decorator）</h3><p>函数也是对象，它有__name__等属性，但经过decorator装饰之后的函数，它们的__name__已经改变为装饰器中的函数名，所以需要把原始函数的__name__等属性复制到装饰器中的函数中，否则，有些依赖函数签名的代码执行就会出错。不需要编写 wrapper.<strong>name</strong> = func.__name__这样的代码，Python 内置functools.wraps 就是干这个事的，所以，一个完整的 decorator 的写法如下：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> functools<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">log</span>(<span class="hljs-params">text</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decorator</span>(<span class="hljs-params">func</span>):</span><br><span class="hljs-meta">        @functools.wraps(<span class="hljs-params">func</span>)</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span>(<span class="hljs-params">*args, **kw</span>):</span><br>            print(<span class="hljs-string">&#x27;&#123;&#125; &#123;&#125;():&#x27;</span>.<span class="hljs-built_in">format</span>(text, func.__name__))<br>            <span class="hljs-keyword">return</span> func(*args, **kw)<br>        <span class="hljs-keyword">return</span> wrapper<br>    <span class="hljs-keyword">return</span> decorator<br></code></pre></div></td></tr></table></figure><h3 id="property"><a href="#property" class="headerlink" title="@property"></a>@property</h3><p>@property 装饰器来创建只读属性，@property 装饰器会将方法转换为相同名称的只读属性 , 可以与所定义的属性配合使用，这样可以防止属性被修改。</p><ol><li><p>修饰方法，是方法可以像属性一样访问</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataSet</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br><span class="hljs-meta">  @property</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">method_with_property</span>(<span class="hljs-params">self</span>):</span> <span class="hljs-comment"># 含有@property</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-number">15</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">method_without_property</span>(<span class="hljs-params">self</span>):</span> <span class="hljs-comment"># 不含@property</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-number">15</span><br><br>l = DataSet()<br>print(l.method_with_property) <span class="hljs-comment"># 加了@property后，可以用调用属性的形式来调用方法,后面不需要加（）。</span><br>print(l.method_without_property())  <span class="hljs-comment"># 没有加@property , 必须使用正常的调用方法的形式，即在后面加()</span><br><span class="hljs-comment"># 两个都输出为 15</span><br></code></pre></div></td></tr></table></figure></li><li><p>与所定义的属性配合使用，这样可以防止属性被修改。</p><p>由于 python 进行属性的定义时，没办法设置私有属性，因此要通过 @property 的方法来进行设置。这样可以隐藏属性名，让用户进行使用的时候无法随意修改。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataSet</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>      self._images = <span class="hljs-number">1</span><br>      self._labels = <span class="hljs-number">2</span> <span class="hljs-comment">#定义属性的名称</span><br><span class="hljs-meta">   @property</span><br>   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">images</span>(<span class="hljs-params">self</span>):</span> <span class="hljs-comment">#方法加入@property后，这个方法相当于一个属性，这个属性可以让用户进行使用，而且用户有没办法随意修改。</span><br>      <span class="hljs-keyword">return</span> self._images<br><span class="hljs-meta">   @property</span><br>   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">labels</span>(<span class="hljs-params">self</span>):</span><br>      <span class="hljs-keyword">return</span> self._labels<br>   l = DataSet()<br><span class="hljs-comment">#用户进行属性调用的时候，直接调用images即可，而不用知道属性名_images，因此用户无法更改属性，从而保护了类的属性。</span><br>   print(l.images) <span class="hljs-comment"># 加了@property后，可以用调用属性的形式来调用方法,后面不需要加（）。</span><br></code></pre></div></td></tr></table></figure></li></ol><p><strong>魔法函数</strong>：</p>]]></content>
    
    
    <categories>
      
      <category>计算机学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pythoh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python基础模块学习</title>
    <link href="/2021/03/13/python%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/03/13/python%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>Python基础模块的了解和学习</p><span id="more"></span><h2 id="内置模块"><a href="#内置模块" class="headerlink" title="内置模块"></a>内置模块</h2><p>🎉</p><h3 id="time模块"><a href="#time模块" class="headerlink" title="time模块"></a>time模块</h3><ol><li><p>时间获取函数</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br>print(time.time())  <span class="hljs-comment"># 获取当前时间戳</span><br>print(time.ctime()) <span class="hljs-comment"># 获取当前时间并以易读方式表示，返回字符串</span><br>print(time.gmtime()) <span class="hljs-comment"># 获取当前时间，表示为计算机可处理的时间格式,UTC时间，以格式化模板输出  &lt;UTC：协调世界时&gt;</span><br>print(time.asctime()) <span class="hljs-comment"># 未被定义，表示当前时间</span><br>print(time.localtime()) <span class="hljs-comment"># 输出当前时间，以格式化模板输出,本地时间</span><br></code></pre></div></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">1615626615.496064<br>Sat Mar 13 17:10:15 2021<br>time.struct_time(tm_year=2021, tm_mon=3, tm_mday=13, tm_hour=9, tm_min=10, tm_sec=15, tm_wday=5, tm_yday=72, tm_isdst=0)<br>Sat Mar 13 17:10:15 2021<br>time.struct_time(tm_year=2021, tm_mon=3, tm_mday=13, tm_hour=17, tm_min=10, tm_sec=15, tm_wday=5, tm_yday=72, tm_isdst=0)<br></code></pre></div></td></tr></table></figure></li><li><p>时间格式化</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br>t = time.gmtime()<br>t1 = time.strftime(<span class="hljs-string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>,t)    <span class="hljs-comment"># 格式化时间</span><br>t2 = time.strptime(t1,<span class="hljs-string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)   <span class="hljs-comment"># 转化时间格式</span><br>print(t1,t2)<br></code></pre></div></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">2021-03-13 08:26:17<br>time.struct_time(tm_year=2021, tm_mon=3, tm_mday=13, tm_hour=8, tm_min=45, tm_sec=48, tm_wday=5, tm_yday=72, tm_isdst=-1)<br></code></pre></div></td></tr></table></figure><p><img src="https://resource.liangzai.online/notebook/20210313234205.png#pic_left" alt="格式化字符串对应属性"></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time    <span class="hljs-comment"># 返回一个CPU级别的精确时间计数，单位为秒</span><br>start = time.perf_counter()<br>time.sleep(<span class="hljs-number">3</span>)    <span class="hljs-comment"># 模拟休眠，可以是浮点数。推迟调用线程的运行，可通过参数 secs 指秒数，表示进程挂起的时间。</span><br>end = time.perf_counter()<br>print(end - start)<br></code></pre></div></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">3.004556<br></code></pre></div></td></tr></table></figure><blockquote><p>perf_counter()适合小一点的程序测试，会计算sleep()时间。<br>time()精确度不高，而且受系统影响，适合表示日期或者大程序的计时。</p></blockquote><hr></li></ol><h3 id="os模块"><a href="#os模块" class="headerlink" title="os模块"></a>os模块</h3><ol><li><p>os模块</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><br>os.listdir(<span class="hljs-string">&quot;path&quot;</span>)[:]  <span class="hljs-comment"># 返回一个列表。列表为给定目录下所有文件和子目录，但不包含特殊目录 . 和 ..。默认为当前目录。</span><br>os.makedirs(<span class="hljs-string">&quot;path&quot;</span>)  <span class="hljs-comment"># 递归方式创建路径为 path 的目录。并以数字形式指定目录权限，默认权限为 777 。可以看作功能更强大的 mkdir，它会自动创建叶子节点目录的所有上级目录，而 mkdir 必须在上级目录已经存在情况下，才能创建叶子节点的目录。</span><br>os.rmdir(<span class="hljs-string">&quot;path&quot;</span>)  <span class="hljs-comment"># 删除目录。目录必须存在，并且只能删除空目录。不存在或不为空，都会异常。要想递归删除整个目录树，请使用 shutil.rmtree()。</span><br>os.removedirs(<span class="hljs-string">&quot;parent/child/newdir&quot;</span>)  <span class="hljs-comment"># 递归删除目录。目录必须存在，并且只能删除空目录。不存在或不为空，都会异常。与 rmdir 不同的是，在删除了叶子节点目录后，会逐次删除上级目录，直到遇到不为空的目录。</span><br>os.remove(<span class="hljs-string">&quot;dog.copy.jpeg&quot;</span>)  <span class="hljs-comment"># 删除文件。不能删除目录，给定路径必须为文件，否则会异常。</span><br>os.getenv(<span class="hljs-string">&quot;PATH&quot;</span>)  <span class="hljs-comment"># 获取环境变量。  getenv(key, default=None)</span><br>os.get_exec_path(<span class="hljs-string">&quot;path&quot;</span>)  <span class="hljs-comment"># 返回用于搜索可执行文件的目录列表。看以看作是 PATH 环境变量的列表形式。</span><br>os.rename(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;newname&quot;</span>)  <span class="hljs-comment"># 重命名文件</span><br>os.remove()  <span class="hljs-comment"># 删除文件</span><br>os.getcwd()  <span class="hljs-comment"># 获取当前工作路径</span><br>os.walk()    <span class="hljs-comment"># 遍历目录</span><br>os.chdir()   <span class="hljs-comment"># 改变当前工作目录</span><br></code></pre></div></td></tr></table></figure></li><li><p>os.path模块</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">os.path.join()  <span class="hljs-comment"># 连接目录与文件名</span><br>os.path.split() <span class="hljs-comment"># 分割文件名与目录</span><br>os.path.abspath()  <span class="hljs-comment"># 获取绝对路径</span><br>os.path.dirname()  <span class="hljs-comment"># 获取路径</span><br>os.path.basename() <span class="hljs-comment"># 获取文件名或文件夹名</span><br>os.path.splitext() <span class="hljs-comment"># 分离文件名与扩展名</span><br>os.path.isfile()   <span class="hljs-comment"># 判断所给出的路径是否是一个文件</span><br>os.path.isdir()    <span class="hljs-comment"># 判断给出的路径是否是一个目录</span><br></code></pre></div></td></tr></table></figure><hr></li></ol><h3 id="json模块"><a href="#json模块" class="headerlink" title="json模块"></a>json模块</h3><ol><li><p>dumps和dump</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br><span class="hljs-comment"># json.dumps(obj, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, encoding=&quot;utf-8&quot;, default=None, sort_keys=False, **kw)</span><br><span class="hljs-comment"># 将 Python 对象编码成 JSON 字符串</span><br>data = [ &#123; <span class="hljs-string">&#x27;a&#x27;</span> : <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span> : <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span> : <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;d&#x27;</span> : <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;e&#x27;</span> : <span class="hljs-number">5</span> &#125; ]<br>data2 = json.dumps(data)<br>data3 = json.dumps(&#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-string">&#x27;Runoob&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">7</span>&#125;, sort_keys=<span class="hljs-literal">True</span>, indent=<span class="hljs-number">4</span>, separators=(<span class="hljs-string">&#x27;,&#x27;</span>, <span class="hljs-string">&#x27;: &#x27;</span>))<br>print(data2,data3,sep=<span class="hljs-string">&#x27;\n&#x27;</span>)<br><br><span class="hljs-comment"># 使用 dumps（）：将可以转换为 json 对象的对象转换为 String，然后可通过字符流或字节流写入文件</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">save_conf</span>(<span class="hljs-params">confiuration_path, pre_trans_obj</span>):</span><br><span class="hljs-comment">#先用dunps转为string，然后字符流写入</span><br><span class="hljs-comment">#ensure_ascii=False, 减少乱码</span><br>    json_string = json.dumps(pre_trans_obj, ensure_ascii=<span class="hljs-literal">False</span>)<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(confiuration_path,<span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        f.write(json_string)<br><br><span class="hljs-comment"># 使用 dump（）：将可转为 json 对象的对象直接写入文件（将两个步骤结合成一个步骤）</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">save_conf</span>(<span class="hljs-params">confiuration_path, pre_trans_obj</span>):</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>（confiuration_path,<span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        json.dump(pre_trans_obj, f, ensure_ascii=<span class="hljs-literal">False</span>)<br><br></code></pre></div></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">[&#123;<span class="hljs-string">&quot;a&quot;</span>: 1, <span class="hljs-string">&quot;b&quot;</span>: 2, <span class="hljs-string">&quot;c&quot;</span>: 3, <span class="hljs-string">&quot;d&quot;</span>: 4, <span class="hljs-string">&quot;e&quot;</span>: 5&#125;]<br>&#123;<br><span class="hljs-string">&quot;a&quot;</span>: <span class="hljs-string">&quot;Runoob&quot;</span>,<br><span class="hljs-string">&quot;b&quot;</span>: 7<br>&#125;<br></code></pre></div></td></tr></table></figure><!-- 表格（table） --><p><strong>Python原始类型向Json类型的转换对照表：</strong></p><table><thead><tr><th align="center">Python</th><th align="center">Json</th></tr></thead><tbody><tr><td align="center">dict</td><td align="center">object</td></tr><tr><td align="center">list,tuple</td><td align="center">array</td></tr><tr><td align="center">str,unicode</td><td align="center">string</td></tr><tr><td align="center">int,long.float</td><td align="center">number</td></tr><tr><td align="center">True</td><td align="center">true</td></tr><tr><td align="center">False</td><td align="center">fasle</td></tr><tr><td align="center">None</td><td align="center">null</td></tr></tbody></table></li><li><p>loads和load</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br><span class="hljs-comment"># json.loads(s[, encoding[, cls[, object_hook[, parse_float[, parse_int[, parse_constant[, object_pairs_hook[, **kw]]]]]]]])</span><br><span class="hljs-comment"># 用于解码 JSON 数据。该函数返回 Python 字段的数据类型。</span><br>jsonData = <span class="hljs-string">&#x27;&#123;&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3,&quot;d&quot;:4,&quot;e&quot;:5&#125;&#x27;</span>;<br>text = json.loads(jsonData)<br>print(text)<br><br><span class="hljs-comment"># 加载配置，configuration_path：配置文件路径</span><br><span class="hljs-comment"># 使用 loads（string）：作用将 string 类型转为 dict 字典或 dict 链表</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load_conf</span>(<span class="hljs-params">configuration_path</span>):</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(configuration_path, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        string = f.read()<br>    <span class="hljs-keyword">return</span> json.loads(string)<br><br><span class="hljs-comment"># 使用 load（file_stream）：作用从文件流直接读取并转换为 dict 字典或 dict 字典链表</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load_conf</span>(<span class="hljs-params">configuration_path</span>):</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(configuration_path, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        data = json.load(f)<br>    <span class="hljs-keyword">return</span> data<br></code></pre></div></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">&#123;<span class="hljs-string">&#x27;a&#x27;</span>: 1, <span class="hljs-string">&#x27;b&#x27;</span>: 2, <span class="hljs-string">&#x27;c&#x27;</span>: 3, <span class="hljs-string">&#x27;d&#x27;</span>: 4, <span class="hljs-string">&#x27;e&#x27;</span>: 5&#125;<br></code></pre></div></td></tr></table></figure><p><strong>Python原始类型向Json类型的转换对照表：</strong></p><table><thead><tr><th align="center">Json</th><th align="center">Python</th></tr></thead><tbody><tr><td align="center">object</td><td align="center">dict</td></tr><tr><td align="center">array</td><td align="center">list</td></tr><tr><td align="center">string</td><td align="center">unicode</td></tr><tr><td align="center">number(int)</td><td align="center">int,long</td></tr><tr><td align="center">number(real)</td><td align="center">float</td></tr><tr><td align="center">true</td><td align="center">True</td></tr><tr><td align="center">false</td><td align="center">False</td></tr><tr><td align="center">null</td><td align="center">None</td></tr></tbody></table></li><li><p>大 JSON 字符串</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tempfile<br>data = [&#123;<span class="hljs-string">&#x27;name&#x27;</span>:<span class="hljs-string">&#x27;rocky&#x27;</span>,<span class="hljs-string">&#x27;like&#x27;</span>:(<span class="hljs-string">&#x27;python&#x27;</span>,<span class="hljs-string">&#x27;c++&#x27;</span>),<span class="hljs-string">&#x27;age&#x27;</span>:<span class="hljs-number">23</span>&#125;]<br>f = tempfile.NamedTemporaryFile(mode = <span class="hljs-string">&#x27;w+&#x27;</span>)<br>json.dump(data,f)<br>f.flush()<br>print(<span class="hljs-built_in">open</span>(f.name,<span class="hljs-string">&#x27;r&#x27;</span>).read())<br></code></pre></div></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">[&#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;rocky&quot;</span>, <span class="hljs-string">&quot;like&quot;</span>: [<span class="hljs-string">&quot;python&quot;</span>, <span class="hljs-string">&quot;c++&quot;</span>], <span class="hljs-string">&quot;age&quot;</span>: 23&#125;]<br></code></pre></div></td></tr></table></figure><blockquote><p>Python 中提供了一个 tempfile 的模块来解决json数据量大时内存溢出的问题</p></blockquote><hr></li></ol><h3 id="Random模块"><a href="#Random模块" class="headerlink" title="Random模块"></a>Random模块</h3><ol><li><p>random模块随机生成元素</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br>print(random.random())  <span class="hljs-comment"># 生成0到1之间的一个随机浮点数</span><br>print(random.randint(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>))  <span class="hljs-comment"># 生成1到10的一个整数型随机数</span><br>print(random.uniform(<span class="hljs-number">1.1</span>,<span class="hljs-number">5.4</span>))  <span class="hljs-comment"># 生成1.1到5.4之间的随机浮点数，区间可以不是整数</span><br>print(random.randrange(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>,<span class="hljs-number">2</span>))  <span class="hljs-comment"># 生成1到100的间隔为2的随机整数</span><br></code></pre></div></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">0.10421592338776642<br>9<br>1.7904868611069884<br>87<br></code></pre></div></td></tr></table></figure></li><li><p>random模块随机选取元素</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br>l = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>print(random.choice(l))  <span class="hljs-comment"># 从对象中随机抽取一个元素</span><br>random.shuffle(l)  <span class="hljs-comment"># 将对象序列打乱,该函数没有返回值，完成一种功能，就是对list进行排序打乱</span><br>print(l)<br>print(random.choice(<span class="hljs-string">&quot;tomorrow&quot;</span>))  <span class="hljs-comment"># 从序列中随机选取一个元素</span><br>print(random.sample(<span class="hljs-string">&quot;tomorrow&quot;</span>,<span class="hljs-number">3</span>))  <span class="hljs-comment"># 从对象中随机抽取指定数量的随机字符</span><br><span class="hljs-keyword">import</span> string<br>print(<span class="hljs-string">&quot;&quot;</span>.join(random.sample(string.ascii_letters + string.digits, <span class="hljs-number">8</span>)))  <span class="hljs-comment"># 从a-z,A-Z中生成指定数量的随机字符</span><br></code></pre></div></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">5<br>[3, 5, 4, 1, 2]<br>o<br>[<span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>]<br>qOnfit8x<br><br></code></pre></div></td></tr></table></figure></li></ol><h3 id="IO模块"><a href="#IO模块" class="headerlink" title="IO模块"></a>IO模块</h3><ol><li><p>StringIO使用</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> io <span class="hljs-keyword">import</span> StringIO  <span class="hljs-comment"># 类似文件的缓冲区</span><br>cache_file = StringIO()<br>print(cache_file.write(<span class="hljs-string">&#x27;hello world&#x27;</span>)) <span class="hljs-comment"># 11</span><br>print(cache_file.seek(<span class="hljs-number">0</span>)) <span class="hljs-comment"># 让指针移动到最开始的位置，否则读取不到内容（写入后指针在最末尾）</span><br>print(cache_file.read()) <span class="hljs-comment"># 读取写入的内容</span><br>print(cache_file.close())  <span class="hljs-comment"># 释放缓冲区（在关闭文件的缓冲区之后就不能再进行读写操作了）</span><br><span class="hljs-comment"># getvalue () 方法：直接获得写入后的 str</span><br></code></pre></div></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">11<br>0<br>hello world<br>None<br></code></pre></div></td></tr></table></figure></li><li><p>BytesIO使用</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> io <span class="hljs-keyword">import</span> BytesIO  <span class="hljs-comment"># 类似文件的缓冲区</span><br>bytes_file = BytesIO()  <span class="hljs-comment"># 操作二进制数据，需要使用 BytesIO</span><br>bytes_file.write(<span class="hljs-string">b&#x27;hello world&#x27;</span>)  <span class="hljs-comment"># BytesIO 实现了在内存中读写 bytes，写入的不是 str，而是经过 UTF-8 编码的 bytes</span><br>bytes_file.seek(<span class="hljs-number">0</span>)<br>print(bytes_file.read()) <span class="hljs-comment"># b&#x27;hello world&#x27;</span><br>bytes_file.close()<br></code></pre></div></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">b<span class="hljs-string">&#x27;hello world&#x27;</span><br></code></pre></div></td></tr></table></figure></li></ol><h3 id="String模块"><a href="#String模块" class="headerlink" title="String模块"></a>String模块</h3><ol><li><p>常用函数</p><table><thead><tr><th align="center">常用函数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><strong>str.capitalize()</strong></td><td align="center">字符串首字母大写</td></tr><tr><td align="center"><strong>str.center(width)</strong></td><td align="center">字符串用空格填充成一个长度为width的字符串，原字符串居中</td></tr><tr><td align="center">str.ljust(width)</td><td align="center">返回一个原字符串左对齐的并使用空格填充至长度width的新字符串</td></tr><tr><td align="center">str.rjust(width)</td><td align="center">返回一个原字符串右对齐的并使用空格填充至长度width的新字符串</td></tr><tr><td align="center">str.zfill(width)</td><td align="center">返回长度为width的字符串，原字符串str右对齐，前面填充0</td></tr><tr><td align="center"><strong>str.counts(s)</strong></td><td align="center">返回字符串s在str中出现的次数</td></tr><tr><td align="center"><strong>str.decode(encoding=’UTF-8’,errors=’strict’)</strong></td><td align="center">以指定编码格式解码字符串</td></tr><tr><td align="center"><strong>str.encode(encoding=’UTF-8’,errors=’strict’)</strong></td><td align="center">以指定编码格式编码字符串</td></tr><tr><td align="center"><strong>str.endwith(s)</strong></td><td align="center">判断字符串str是否以字符串s结尾</td></tr><tr><td align="center"><strong>str.startswith(s)</strong></td><td align="center">检查字符串str是否以s开头，是则返回True，否则返回False</td></tr><tr><td align="center"><strong>str.find(s)</strong></td><td align="center">返回字符串s在字符串str中的位置索引，没有则返回-1</td></tr><tr><td align="center"><strong>str.replace(a,b)</strong></td><td align="center">将字符串中str中的a替换成b</td></tr><tr><td align="center"><strong>str.split(s)</strong></td><td align="center">以s为分隔符切片str</td></tr><tr><td align="center"><strong>str.splitlines(s)</strong></td><td align="center">按照行分隔，返回一个包含各行作为元素的列表</td></tr><tr><td align="center">str.rfind(s)</td><td align="center">类似于find()函数，但是从右边开始</td></tr><tr><td align="center">str.index(s)</td><td align="center">和find()方法一样，但如果s不存在与str则抛出异常</td></tr><tr><td align="center">str.rindex(s)</td><td align="center">类似于index()函数，但是从右边开始</td></tr><tr><td align="center">str.isalunm()</td><td align="center">如果str至少有一个字符并且都是字母或者数字则返回True否则返回False</td></tr><tr><td align="center">str.isalpha()</td><td align="center">如果str至少有一个字符并且都是字母则返回True否则返回False</td></tr><tr><td align="center">str.isdigit()</td><td align="center">如果str只包含数字则返回True否则返回False</td></tr><tr><td align="center">str.isspace()</td><td align="center">如果str中只包括空格，则返回True，否则返回False</td></tr><tr><td align="center">str.istitle()</td><td align="center">如果str是首字母大写的则返回True，否则返回False</td></tr><tr><td align="center"><strong>str.title()</strong></td><td align="center">返回标题化的str，所有单词都是以大写开始，其余字母均为小写</td></tr><tr><td align="center"><strong>str.upper()</strong></td><td align="center">返回str所有字符串为大写的字符串</td></tr><tr><td align="center"><strong>str.lower()</strong></td><td align="center">转换str中所有大写字符为小写</td></tr><tr><td align="center">str.isupper()</td><td align="center">如果str存在区分大小写的字符，并且都是大写则返回True否则返回False</td></tr><tr><td align="center">str.islower()</td><td align="center">如果str存在区分大小写的字符，并且都是小写则返回True否则返回False</td></tr><tr><td align="center">str.lstrip()</td><td align="center">去掉str左边的不可见字符</td></tr><tr><td align="center">str.rstrip()</td><td align="center">去掉str右边的不可见字符</td></tr><tr><td align="center"><strong>str.strip()</strong></td><td align="center">等同于同时执行rstrip()和lstrip()</td></tr><tr><td align="center">str.partiton(s)</td><td align="center">用s将str切分成三个值</td></tr><tr><td align="center">str.rpartition(s)</td><td align="center">类似于partition()函数，但是从右边开始查找</td></tr></tbody></table></li><li><p>字符串常量</p><table><thead><tr><th align="center">常量</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">string.ascii_lowercase</td><td align="center">小写字母a-z</td></tr><tr><td align="center">string.ascii_uppercase</td><td align="center">大写字母A-Z</td></tr><tr><td align="center">string.ascii_letters</td><td align="center">string.ascii_lowercase和string.ascii_uppercase常量的连接串</td></tr><tr><td align="center">string.digits</td><td align="center">字符串数字0-9</td></tr><tr><td align="center">string.hexdigits</td><td align="center">字符串’0123456789abcdefABCDEF’</td></tr><tr><td align="center">string.letters</td><td align="center">字符串a-Z’</td></tr><tr><td align="center">string.octdigits</td><td align="center">字符串’01234567</td></tr><tr><td align="center">string.lowercase</td><td align="center">小写字母的字符串</td></tr><tr><td align="center">string.uppercase</td><td align="center">大写字母的字符串</td></tr><tr><td align="center">string.punctuation</td><td align="center">所有标点符号</td></tr><tr><td align="center">string.whitespace</td><td align="center">空白字符’\t\n\x0b\xoc\r’</td></tr></tbody></table></li><li><p>字符串模板Template（使用时查询）</p></li></ol><h3 id="Math模块"><a href="#Math模块" class="headerlink" title="Math模块"></a>Math模块</h3><ol><li><p>常用函数</p><table><thead><tr><th align="center">函数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><strong>math.e</strong></td><td align="center">自然常数e</td></tr><tr><td align="center"><strong>math.p</strong></td><td align="center">圆周率pi</td></tr><tr><td align="center">math.degrees(x)</td><td align="center">弧度转度</td></tr><tr><td align="center">math.radians(x)</td><td align="center">度转弧度</td></tr><tr><td align="center">math.exp(x)</td><td align="center">返回e的x次方</td></tr><tr><td align="center">math.expm1(x)</td><td align="center">返回e的x次方减一</td></tr><tr><td align="center">math.log(x[,base])</td><td align="center">返回x的以base为底的对数，base默认为e</td></tr><tr><td align="center">math.log10(x)</td><td align="center">返回x的以10为底的对数</td></tr><tr><td align="center">math.log1p(x)</td><td align="center">返回1+x的自然对数（以e为底）</td></tr><tr><td align="center">math.pow(x,y)</td><td align="center">返回x的y次方</td></tr><tr><td align="center">math.sqrt(x)</td><td align="center">返回x的平方根</td></tr><tr><td align="center"><strong>math.ceil(x)</strong></td><td align="center">返回不小于x的整数</td></tr><tr><td align="center"><strong>math.floor(x)</strong></td><td align="center">返回不大于x的整数</td></tr><tr><td align="center">math.trunc(x)</td><td align="center">返回x的整数部分</td></tr><tr><td align="center">math.modf(x)</td><td align="center">返回x的小数和整数</td></tr><tr><td align="center">math.fmod(x)</td><td align="center">返回x%y（取余）</td></tr><tr><td align="center">math.fabs(x)</td><td align="center">返回x的绝对值</td></tr><tr><td align="center">math.fsum([x,y,…])</td><td align="center">返回无损精度的和</td></tr><tr><td align="center"><strong>math.factorial(x)</strong></td><td align="center">返回x的阶乘</td></tr><tr><td align="center">math.isinf(X)</td><td align="center">若x为无穷大，返回True；否则，返回False</td></tr><tr><td align="center"><strong>math.isnan(x)</strong></td><td align="center">若x不是数字，返回True；否则，返回False</td></tr><tr><td align="center">math.hypot(x, y)</td><td align="center">返回以x和y为直角边的斜边长</td></tr><tr><td align="center">math.copysign(x, y)</td><td align="center">若y&lt;0，返回-1乘以x的绝对值；否则，返回x的绝对值</td></tr><tr><td align="center">math.sin(x)</td><td align="center">返回x（弧度）的三角正弦值</td></tr><tr><td align="center">math.asin(x)</td><td align="center">返回x的反三角正弦值</td></tr><tr><td align="center">math.cos(x)</td><td align="center">返回x（弧度）的三角余弦值</td></tr><tr><td align="center">math.acos(x)</td><td align="center">返回x的反三角余弦值</td></tr><tr><td align="center">math.tan(x)</td><td align="center">返回x（弧度）的三角正切值</td></tr><tr><td align="center">math.atan(x)</td><td align="center">返回x的反三角正切值</td></tr><tr><td align="center">math.atan2(x, y)</td><td align="center">返回x/y的反三角正切值</td></tr><tr><td align="center">……</td><td align="center">……</td></tr></tbody></table></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-python -基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux学习记录</title>
    <link href="/2021/03/08/Linux%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/03/08/Linux%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="Linux基础知识"><a href="#Linux基础知识" class="headerlink" title="Linux基础知识"></a>Linux基础知识</h2><span id="more"></span><ol><li><p>linux系统组成：内核、Shell、文件管理系统和应用程序。  </p><blockquote><p>内核：运行程序和管理磁盘和打印机等硬件设备的核心<br>Shell：是系统的用户界面，提供了用户与内核进行交互操作的一种接口，接受用户输入的命令并把它送入到内核中去执行。<br>文件系统：是文件存放在磁盘等存储设备上的组织方法<br>应用程序：程序集  </p></blockquote></li><li><p>linux发行版本  </p><ul><li>RedHat  </li><li>Fedora（由Redhat发展而来）  </li><li>Debian  </li><li>Ubuntu（基于Debian）  </li><li>Slackware</li><li>OpenSUSE</li></ul></li></ol><h2 id="Shell的基本运用"><a href="#Shell的基本运用" class="headerlink" title="Shell的基本运用"></a>Shell的基本运用</h2><h3 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h3><ol><li><p>Shell简介  </p><p> Shell是Linux的一个特殊程序，是内核与用户的接口，是命令语言、命令解释器及程序设计语言的统称。是一个命令语言解释器，拥有自己的Shell命令集，也能被系统中其他应用程序调用。</p></li><li><p>Shell终端  </p></li></ol><ul><li><p>Shell命令提示符</p><div class="hljs code-wrapper"><pre><code class="bash">[root@localhost ~]#   超级用户的命令提示符[name@localhost ~]$   普通用户name的命令提示符</code></pre></div><p>  @之前的为已登陆的用户名，以后的为计算机的主机名，默认为localhost，其次为当前目录名。（~表示用户主目录）</p></li><li><p>Shell命令格式</p><p>命令名 [选项] [参数]</p><ul><li>命令名是描述该命令功能的英语单词或缩写；</li><li>选项是执行该命令的限定参数或者功能参数,通常以’-‘开头，当有多个选项时，可以只使用一个该符号。部分选项以’–’开头，这些选项通常是一个单词，还有少数命令的选项不需要’-‘符号；</li><li>参数是执行该命令所必须的对象，如文件、目录；  </li><li>在Shell中一行中可以键入多行命令，用’;’分隔。在一行命令后加’&#39;表示另起一行继续输入。使用Tab键可以自动补全。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C基础</title>
    <link href="/2021/03/06/c%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/03/06/c%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p><strong>程序</strong>：为了让计算机执行某些操作或解决某个问题而编写的一系列有序指令的集合</p><blockquote><p>计算机指令：指挥机器工作的指示和命令</p></blockquote><p><strong>算法</strong>：是一个定义明确的计算过程，可以将一些值或一组值作为输入并产生一些值或一组值作为输出。因此算法就是将输入转化为输出的一系列计算步骤</p><p><strong>编译和执行过程</strong>：</p><blockquote><ol><li>编译：形成目标文件/代码。目标文件是编译器的输出结果，常见扩展名为“.o”或“.obj”</li><li>连接：将目标代码跟C函数库相连接，并将源程序所用的库代码与目标代码合并形成最终可执行的二进制机器代码</li><li>执行：在特定的机器环境下运行C应用程序</li></ol></blockquote><p>计算机使用内存来记忆或存储计算时所使用的数据</p><blockquote><p>计算机在执行程序时，组成程序的指令和程序所操作的数据都必须存放在计算机的内存中<br>内存：也成为主存（main memory）或随机访问储存器（Random Access Memorry）</p></blockquote><p>bit（位），binary digit（二进制数字）</p><p>8 bit(比特) = 1 byte(字节)</p><p><strong>变量</strong>：计算机中一块特定的内存空间，由一个或多个连续的字节组成</p><p><strong>C语言变量命名规则</strong>：</p><blockquote><ol><li>只能由字母、数字和下划线三种字符组成，且第一个字母必须位字母或下划线</li><li>变量名不能包含除_以外的任何特殊字符</li><li>不可以使用保留字</li></ol></blockquote><p><strong>数据类型</strong>：</p><blockquote><ul><li>数值<ul><li>整形<ul><li>int</li><li>short</li><li>long</li></ul></li><li>非整形<ul><li>float</li><li>double</li></ul></li></ul></li><li>非数值<ul><li>char</li><li>str</li></ul></li></ul></blockquote><p>清除缓冲区  fflush(stdin)</p><p><strong>运算符</strong>：</p><blockquote><ul><li>赋值运算符</li><li>算术运算符<ul><li>一元运算符: ++、–</li><li>二元运算符：+、-、*、/、%</li></ul></li><li>关系运算符</li><li>逻辑运算符：&amp;&amp;且、||或、!非</li><li>位运算符</li></ul></blockquote><p><strong>使用switch结构时的注意点</strong>：</p><blockquote><ol><li>switch后的表达式只能是整型或字符型</li><li>case后常量表达式的值不能相同</li><li>case后允许多条语句，不需要大括号</li><li>如果不添加break语句，需要特别注意执行顺序</li><li>default子句可以省略</li></ol></blockquote><p><strong>continue</strong>: 跳过本次循环，继续下次循环</p><p><strong>数组</strong>：是一个变量，由数据类型相同的一组元素组成的</p><blockquote><ol><li>标识符：数组的名称，用于区分不同的数组</li><li>数组元素：向数组中存放的数据</li><li>元素下标：对数组元素进行编号</li><li>元素类型：数组元素的数据类型</li></ol></blockquote><p><strong>枚举</strong>：enum　枚举名　{枚举元素1,枚举元素2,……} 枚举变量</p><blockquote><p>每一个变量都有一个内存地址，每一个内存位置都定义了可使用&amp;运算符访问的地址，它表示了在内存中的一个地址。</p></blockquote><p><strong>指针</strong>：指针也就是内存地址，指针变量用来存放内存地址的变量，就像其他变量或常量一样，必须在使用指针存储其他变量地址之前，对其进行声明。type *var-name  星号用来指定一个变量是指针</p><blockquote><ol><li>所有实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，对应指针的值的类型都是一样的，都是一个代表内存地址的长的十六进制数。不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。</li><li>通过使用一元运算符 * 来返回位于操作数所指定地址的变量的值</li><li>在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为空指针。</li><li>在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。</li></ol></blockquote><p><strong>C指针的算数运算</strong>：C 指针是一个用数值表示的地址。因此，您可以对指针执行算术运算。可以对指针进行四种算术运算：++、–、+、-。</p><blockquote><ol><li>指针的每一次递增，它其实都会指向下一个元素的存储单位</li><li>指针的每一次递减，它都会指向前一个元素的存储单位</li><li>指针在递增和递减时跳跃的字节数取决于指针所指向变量数据类型长度，比如int就是4个字节</li><li>指针可以用关系运算符进行比较，如 ==、&lt;和&gt;。如果 p1 和 p2 指向两个相关的变量，比如同一个数组中的不同元素，则可对 p1 和 p2 进行大小比较。</li></ol></blockquote><p><strong>指针数组</strong>：int *ptr[MAX];</p><blockquote><p>把 ptr 声明为一个数组，由 MAX 个整数指针组成。因此，ptr 中的每个元素，都是一个指向 int 值的指针。 也可以用一个指向字符的指针数组来存储一个字符串列表。ptr[i] →*(ptr + i)</p></blockquote><p><strong>C指向指针的指针</strong>：指向指针的指针时一种多级间寻址的形式，或者说是一个指针链。当我们定义一个指向指针的指针时，第一个指针包含了第二个指针的地址，第二个指针指向包含实际值的位置。一个指向指针的指针变量必须如下声明，即在变量名前放置两个星号： int **var;</p><blockquote><p>当一个目标值被一个指针间接指向到另一个指针时，访问这个值需要使用两个星号运算符</p></blockquote><p><strong>C传递指针给函数</strong>：C 语言允许传递指针给函数，只需要简单地声明函数参数为指针类型即可</p><blockquote><p>能接受指针作为参数的函数，也能接受数组作为参数</p></blockquote><p><strong>函数指针</strong>：是指向函数的指针变量</p><blockquote><p>通常我们说的指针变量是指向一个整形、字符型或数组等变量，而函数指针是指向函数，函数指针可以像一般函数一样，用于调用函数、传递参数。</p></blockquote><p><strong>函数</strong>：</p><blockquote><ol><li>是完成特定任务的独立程序代码</li><li>语法规则定义了函数的结构和使用方式</li></ol></blockquote><p>零表示假，非零表示真</p><p><strong>关于free函数</strong>：</p><blockquote><ol><li>必须是通过molloc、calloc或realloc分配内存的指针</li><li>释放的指针必须是初始分配的地址，进行运算后需要恢复</li></ol></blockquote><p><strong>自定义函数</strong>：</p><blockquote><ul><li>函数三要素：<ul><li>返回值类型</li><li>函数名</li><li>参数列表</li></ul></li><li>返回值<ul><li>关键字：return</li><li>只能返回一个值，不能返回多个值</li><li>返回值类型必须与原型中的返回值类型匹配</li><li>return会立即终止函数并返回，可返回空值</li></ul></li><li>参数<ul><li>形式参数</li><li>实际参数</li></ul></li></ul></blockquote><p>declare：宣布；宣告；宣称；表明 网络 声明；申报；断言</p><p><strong>变量的存储类型</strong>：</p><blockquote><ol><li>auto     自动存储</li><li>register 寄存器存储</li><li>static   静态存储</li><li>extern   外部变量</li></ol></blockquote><p><strong>变量的生存周期</strong>：</p><blockquote><ol><li>变量的存储方式：动态存储（自动、寄存器）、静态存储（静态和外部）</li><li>由变量的存储方式不同而产生的特性称为变量的生存期（变量的存在时间）</li><li>基本类型的静态变量系统默认赋初值为0</li><li>静态变量的生存周期为整个源程序，作用域只是定义它的文件</li><li>函数被调用时，其中的局部静态变量的值保留前次被调用的结果</li></ol></blockquote><p><strong>按值传递</strong>：给函数传递变元（参数）时，变元（参数）值不会直接传递给函数，而是先制作变元（参数）值的副本，存储在栈上，再使这个副本可用于函数，而不是使用初始值。</p><p><strong>引用传递</strong>：指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数</p><p><strong>自定义头文件</strong>：一般放一些重复使用的代码，例如函数声明，变量声明，常量声明，宏的定义等</p><blockquote><ol><li>MYHEADER_H_INCLUDED为一个唯一的标记，命名规则跟变量的命名规则一样，常根据它所在的头文件名来命名</li><li>代码含义：如果没有定义MYHEADER_H_INCLUDED，则定义MYHEADER_H_INCLUDED，并编译下面的代码部分，直到遇到#endif</li></ol></blockquote><p><strong>字符串</strong>：</p><blockquote><ol><li>一个或多个字符的序列称为字符串</li><li>双引号不是字符串的一部分，仅用来告知编译器括起来的是字符串</li><li>C语言中字符串使用字符数组存储</li><li>声明存储字符串的数组时，数组大小至少比所存储的字符数多1，因为编译器会自动在字符串常量的末尾添加空字符\0</li></ol></blockquote><p><strong>gets和puts函数</strong>：</p><blockquote><ul><li>gets函数不对接受字符串的buffer进行边界检测，会造成越界，从而产生bug</li><li>可以使用fgets(words1, 20, stdin);代替gets，20表示最多读取20-1个字符，默认给最后一个元素回车</li><li>三种方式录入字符串<ul><li>scanf(“%s”, str);</li><li>gets(str);</li><li>fgets(str, 50, stdin);</li></ul></li></ul></blockquote><p><strong>常用字符串处理函数</strong>：</p><blockquote><ol><li>size_t strlen(const char *)  获取字符串长度</li><li>char <em>strupr(char</em>)  将字符串转换为大写</li><li>char <em>strlwr(char</em>)  将字符串转换为小写</li><li>char <em>strcopy(char</em>, const char *)  把第二个字符串复制到第一个字符串数组中</li><li>in strcmp(const char*, constr char*)  根据ASCII码比较字符串</li><li>char <em>strcat(char</em>, const char *)    字符串连接，把第二个元素连接到第一个元素后</li></ol></blockquote><p>数组为常量</p><blockquote></blockquote><p><strong>指向字符串的指针</strong>：</p><blockquote><ul><li>将指针指向字符串<ul><li>可以指向常量字符串</li><li>也可以指向存储字符串的字符数组</li></ul></li><li>数组形式和执行形式的不同<ul><li>初始化字符数组时会把静态存储区的字符串拷贝到数组中</li><li>初始化指针时只把字符串的地址拷贝给指针</li></ul></li></ul></blockquote><p><strong>结构</strong>：一种构造数据类型，由若干个数据项组合而成</p><blockquote><p>struct StructName<br>{<br>//结构成员<br>DataType1 var1;<br>DataType2 var2;<br>//…<br>} VAR1, VAR2;</p><ol><li>结构定义并不预留内存</li><li>结构定义一般放在程序的开始部分（头文件声明之后）</li><li>结构定义仅用来描述结构的形式，使用结构需要声明结构变量</li><li>定义结构的同时，声明结构变量</li></ol></blockquote><p><strong>指向结构的指针</strong>：</p><blockquote><ul><li>一个指针指向结构时，称为结构指针变量</li><li>结构指针变量中的值是所指向的结构变量的首地址</li><li>一般形式：struct 结构名称 结构指针变量名;</li><li>访问结构成员的一般形式：<ul><li>(*结构指针变量).成员变量名</li><li>结构指针变量-&gt;成员变量名</li></ul></li></ul></blockquote><p><strong>结构数组</strong>：元素为结构类型的数组</p><p><strong>向函数传递结构的信息</strong>：</p><blockquote><ul><li>结构作为函数参数的三种方式<ul><li>传递结构成员</li><li>传递结构<ul><li>优点：函数处理的是原始数据的副本，保护了原始数据</li><li>缺点：老版本不支持；传递结构浪费时间和存储空间</li><li>一般用来处理小型数据结构</li></ul></li><li>传递结构的地址<ul><li>优点：程序的执行速度快，效率高</li><li>缺点：无法保护数据，函数中的操作可能会意外影响原结构中的数据</li><li>为了最求效率，常用此方案</li></ul></li></ul></li></ul></blockquote><p><strong>typedef</strong>：可以为某一类型自定义名称</p><blockquote><p>并没有创造任何新类型，只是为某个已存在的类型增加一个方便使用的标签</p></blockquote><p>枚举和联合</p>]]></content>
    
    
    <categories>
      
      <category>计算机学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
